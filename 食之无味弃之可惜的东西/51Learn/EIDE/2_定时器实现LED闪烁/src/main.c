#include <STC89C5xRC.H>

/*
  * 51单片机STC89C52RC配置定时器的方法:以定时器0为例
  * 1. 配置TMOD定时器,来选择单片机的工作模式:TMOD = 0x01;
    此时是0000 0001,高4位是控制定时器T1的,所以高四位都置0,低四位分别是T0_GATE, T0_C/T, T0_M1, T0_M0
    T0_GATE:定时器0的门控信号,0为低电平触发,1为高电平触发
    T0_C/T:配置是作为定时器还是计数器,清0用作定时器,置1作为计数器
    T0_M1和T0_M0:定时器0的计数器模式,00为13位定时器,01为16位定时器,10为8位定时器,11为3位定时器
  * 2. 设置定时器初值:因为我们在TMOD配置了T0为16位寄存器,所以需要设置TH0和TL0两个寄存器,TH0为高8位寄存器,TL0为低8位寄存器,
      其次要知道晶振频率,我们的单片机上用的晶振是11.0592MHz
      51的时钟周期为:1/11.0592MHz,振动1次则需要1/11.0592us
      51的机器周期为:12/11.0592MHz,那么定时器每加1,时间就过了12/11.0592us
      经过计算  加x次 * 12/11.0592us= y微秒,那么需要加多少次的x=y/(12/11.0592us).
      经过计算当y=10000微秒时,x=9216次,也就是定时器的初值应为65536-9216=56320,
      TH0 = 56320 / 256 = 220 → 0xDC
      TL0 = 56320 % 256 = 0 → 0x00
  * 3. 配置TCON控制寄存器,来开启定时器以及清除溢出标志:
        TF0 = 0; // 清除定时器0溢出标志
        TR0 = 1; // 启动定时器0,允许定时器0计数
        // IE0和IT0是外部中断0的控制位，与定时器0无关
  * 4. 如果要使用定时器中断，还需要配置中断使能寄存器：
        ET0 = 1;  // 允许定时器0中断
        EA = 1;   // 开启总中断
 */

// 定义LED控制引脚
sbit LED = P2 ^ 0;

// 定时器0初始化函数
void Timer0_Init(void)
{
    TMOD &= 0xF0; // 清除定时器0模式位
    TMOD |= 0x01; // 设置定时器0为模式1（16位定时器）
    // 移除 ET0 和 EA 设置，因为延时函数使用查询方式而非中断
}

// 10ms延时函数（优化版）
void delay_10ms(unsigned int count)
{
    // 使用静态变量保存初值，避免硬编码
    static const unsigned char TH0_VAL = 0xDC;
    static const unsigned char TL0_VAL = 0x00;

    unsigned int i;

    // 安全启动序列
    TR0 = 0;       // 确保定时器停止
    TF0 = 0;       // 清除溢出标志
    TH0 = TH0_VAL; // 设置初值
    TL0 = TL0_VAL;
    TR0 = 1; // 启动定时器

    for (i = 0; i < count; i++)
    {
        while (!TF0)
        {
            /* 空循环等待溢出 */
        }

        // 关键顺序：先重装后清除
        TH0 = TH0_VAL; // 1. 重装初值
        TL0 = TL0_VAL;
        TF0 = 0; // 2. 清除溢出标志
    }

    TR0 = 0; // 停止定时器
}

void main()
{
    // 添加LED初始化
    LED = 1;       // 初始状态设为灭
    Timer0_Init(); // 初始化定时器0

    while (1)
    {
        // 优化：使用明确的状态控制
        LED = 0;        // LED亮
        delay_10ms(50); // 亮500ms
        LED = 1;        // LED灭
        delay_10ms(50); // 灭500ms
    }
}
