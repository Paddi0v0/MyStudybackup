#include <STC89C5xRC.H>
#include <stdio.h>
// 位选：
// LED1:P22输出低电平0 P23输出低电平0 P24输出低电平0 其余端口全部置高电平 即1110 0011 此时Y1选中即LE1：P2 &= 0xe3;， P2 |= 0xe3
// LED2:p22输出高电平1 P23输出低电平0 P24输出低电平0 其余端口全部置高电平 即1110 0111 此时Y2选中即LE2：P2 &= 0xe3;， P2 |= 0xe7
// LED3:P22输出高电平0 P23输出高电平1 P24输出低电平0 其余端口全部置高电平 即1110 1011 此时Y3选中即LE3：P2 &= 0xe3;，P2 |= 0xeb
// LED4:P22输出高电平1 P23输出高电平1 P24输出高电平0 其余端口全部置高电平 即1110 1111 此时Y4选中即LE4：P2 &= 0xe3;， P2 |= 0xef
// LED5:P22输出低电平0 P23输出高电平0 P24输出高电平1 其余端口全部置高电平 即1111 0011 此时Y5选中即LE5：P2 &= 0xe3;， P2 |= 0xf3
// LED6:P22输出低电平1 P23输出低电平0 P24输出高电平1 其余端口全部置高电平 即1111 0111 此时Y6选中即LE6：P2 &= 0xe3;， P2 |= 0xf7
// LED7:P22输出低电平0 P23输出低电平1 P24输出低电平1 其余端口全部置高电平 即1111 1011 此时Y7选中即LE7：P2 &= 0xe3;， P2 |= 0xfb
// LED8:P22输出低电平1 P23输出低电平1 P24输出低电平1 其余端口全部置高电平 即1111 1111 此时Y8选中即LE8：P2 &= 0xe3;， P2 |= 0xff

// 段选：
// 显示0 0011 1111, P0 &= 0x00, P0 |= 0X3F
// 显示1 0000 0110, P0 &= 0x00, P0 |= 0X06
// 显示2 0101 1011, P0 &= 0x00, P0 |= 0X5B
// 显示3 0100 1111, P0 &= 0x00, P0 |= 0X4F
// 显示4 0110 0110, P0 &= 0x00, P0 |= 0X66
// 显示5 0110 1101, P0 &= 0x00, P0 |= 0X6D
// 显示6 0111 1101, P0 &= 0x00, P0 |= 0X7D
// 显示7 0000 0111, P0 &= 0x00, P0 |= 0X07
// 显示8 0111 1111, P0 &= 0x00, P0 |= 0X7F
// 显示9 0110 1111, P0 &= 0x00, P0 |= 0X6F

// 先消影，后选通，再送段，防鬼影！
/*
标准数码管动态显示操作流程
先关闭段选（消影）
让所有段都熄灭，防止段码信号串到其它数码管上，出现"鬼影"现象。
关闭位选
让所有数码管都不被选中（位选全高），此时即使段选有信号，也不会有数码管被点亮。
开启当前位选
只选中你要点亮的那个数码管（某一位拉低），其它位保持高电平。
设置段选
输出你要显示的数字对应的段码信号，此时只有被选中的数码管会显示数字，其它数码管不会受影响。
    P0 &= 0x00; // 先关闭段选（消影）
    P2 &= 0xe3; // 关闭位选
    P2 |= 0xf7; // 开启当前位选
    P0 |= 0X06; // 设置段选
*/
/*
为什么显示8时，小数点位会亮？
1. ?锁存器使能信号冲突?：当使用74HC138（位选）和74HC573（段选）驱动时，若锁存器使能信号（LE）的时序不匹配，会导致段选数据覆盖位选信号，使小数点异常点亮56。
?2. 电流串扰?：显示"8"时所有段均导通，电流增大可能通过寄生电容耦合到小数点线路（DP）7。建议在DP引脚增加下拉电阻（共阴）或上拉电阻（共阳）。
*/

// int nums[] = {0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F};
// int LED[] = {0Xe3, 0Xe7, 0Xeb, 0Xef, 0Xf3, 0Xf7, 0Xfb, 0Xff};
typedef unsigned char u8;
u8 code nums[] = {0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7f, 0X6F};
u8 code LEDs[] = {0Xe3, 0Xe7, 0Xeb, 0Xef, 0Xf3, 0Xf7, 0Xfb, 0Xff};

void LedDisplay(u8 LED, u8 num)
{
    P0 &= 0x00;             // 先关闭段选（消影）
    P2 &= 0xe3;          // 关闭位选
    P2 |= LEDs[LED - 1]; // 开启当前位选
    // 特殊处理数字8：强制清除DP位（共阴极）
    P0 |= nums[num];
    // P0 = (num == 8) ? (nums[num] & 0x7F) : nums[num];
    // P0 = nums[num];      // 设置段选
}

void main()
{
    while (1)
    {
        LedDisplay(3, 9);
    }
}
